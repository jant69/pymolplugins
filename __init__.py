'''
PyMOL Plugins Engine

(c) 2011-2012 Thomas Holder, PyMOL OS Fellow
License: BSD-2-Clause

'''

import os
import sys
import pymol
from pymol import cmd
from .legacysupport import *

# variables

preferences = {
    'verbose': True,
    'instantsave': True,
}

autoload = {}

plugins = {}

# API functions

def get_startup_path():
    return startup.__path__

def set_startup_path(p, autosave=True):
    if isinstance(p, list) and len(p) > 0:
        startup.__path__ = p
        if autosave:
            set_pref_changed()
    else:
        print ' Error: set_startup_path failed'

def pref_set(k, v):
    preferences[k] = v
    set_pref_changed()

def pref_get(k, d=None):
    return preferences.get(k, d)

def pref_save(filename='~/.pymolrc_plugins.py', quiet=1):
    import pprint
    repr = pprint.pformat

    try:
        f = open(cmd.exp_path(filename), 'w')
    except IOError:
        print ' Error: Cannot write to', filename
        return

    print >> f, '# AUTOGENERATED FILE'
    print >> f, 'try:'
    print >> f, '  import', __name__
    print >> f, '  ' + __name__ + '.autoload =', repr(autoload)
    print >> f, '  ' + __name__ + '.preferences =', repr(preferences)
    print >> f, '  ' + __name__ + '.set_startup_path(', repr(get_startup_path()), ', False)'
    print >> f, 'except:'
    print >> f, '  import os'
    print >> f, '  print "Error while loading " + os.path.abspath(__script__)'
    f.close()

    if not int(quiet):
        print ' Plugin settings saved!'

def set_pref_changed():
    if pref_get('instantsave', True):
        verbose = pref_get('verbose', False)
        pref_save(quiet=not verbose)

def addmenuitem(label, command=None, menuName='Plugin'):
    '''
    Generic replacement for MegaWidgets menu item adding
    '''
    labels1 = [menuName] + label.split('|')
    labels2 = ['|'.join(labels1[0:i]) for i in range(1, len(labels1))]
    pmgapp = get_pmgapp()
    if pmgapp is not None:
        for i in range(1, len(labels2)):
            try:
                pmgapp.menuBar.addcascademenu(labels2[i-1], labels2[i], label=labels1[i])
            except ValueError:
                pass
        if labels1[-1] == '-':
            pmgapp.menuBar.addmenuitem(labels2[-1], 'separator')
        else:
            pmgapp.menuBar.addmenuitem(labels2[-1], 'command', label=labels1[-1],
                    command=command)

def plugin_load(name, quiet=1):
    '''
DESCRIPTION

    Load plugin from command line.
    '''
    if name not in plugins:
        print ' Error: no such plugin'
        return
    info = plugins[name]
    if info.loaded:
        if not int(quiet):
            print ' info: plugin already loaded'
        return
    info.load()

# helper functions and classes

class PluginInfo(object):
    '''
    Hold all information about a plugin.
    '''
    def __init__(self, name, mod_name, filename, register=True):
        self.name = name
        self.mod_name = mod_name
        self.filename = filename

        # set on loading
        self.loadtime = None
        self.commands = []

        # register
        if register:
            plugins[name] = self

    def __repr__(self):
        return '%s(%s)' % (self.__class__.__name__, self.name)

    @property
    def autoload(self):
        return autoload.get(self.name, True)

    @autoload.setter
    def autoload(self, value):
        autoload[self.name] = bool(value)
        set_pref_changed()

    @property
    def module(self):
        return sys.modules.get(self.mod_name)

    @property
    def loaded(self):
        return self.loadtime is not None

    def get_metadata(self):
        '''
        Parse plugin file for metadata (hash-commented block at beginning of file).
        '''
        metadata = dict()
        f = open(self.filename)
        for line in f:
            if line.strip() == '':
                continue
            if not line.startswith('#'):
                break
            if ':' in line:
                key, value = line[1:].split(':', 1)
                metadata[key.strip()] = value.strip()
        f.close()
        self.get_metadata = lambda: metadata
        return metadata

    def get_version(self):
        '''
        Get version as string. If no version available, return empty string.

        Preferred way to specify version is metadata "Version" field.
        '''
        v = self.get_metadata().get('Version', '')
        if not v and self.loaded:
            v = getattr(self.module, '__version__', '')
        return str(v)

    def get_citation_required(self):
        '''
        Return True if Citation-Required: Yes
        '''
        v = self.get_metadata().get('Citation-Required', 'No')
        return v.lower() == 'yes'

    def load(self, pmgapp=None, force=0):
        '''
        Load and initialize plugin.
        '''
        import types, time
        from pymol import cmd

        starttime = time.time()
        if pmgapp is None:
            pmgapp = get_pmgapp()

        verbose = pref_get('verbose', False)

        try:
            # overload cmd.extend to register commands
            extend_orig = cmd.extend
            def extend_overload(name, function):
                extend_orig(name, function)
                self.commands.append(name)
            cmd.extend = extend_overload

            # do not use self.loaded here
            if force and self.module is not None:
                reload(self.module)
            else:
                __import__(self.mod_name, level=0)
            mod = self.module

            if hasattr(mod, '__init_plugin__'):
                mod.__init_plugin__(pmgapp)
            elif hasattr(mod, '__init__'):
                # ignore the build-in <method-wrapper '__init__'> that takes a
                # string as first argument. Only call __init__ if it's of type
                # 'function'
                if isinstance(mod.__init__, types.FunctionType):
                    mod.__init__(pmgapp)

            cmd.extend = extend_orig

            self.loadtime = time.time() - starttime
            if verbose and pymol.invocation.options.show_splash:
                print ' Plugin "%s" loaded in %.2f seconds' % (self.name, self.loadtime)
        except:
            if verbose:
                import traceback
                traceback.print_exc()
            print "Unable to initialize plugin '%s' (%s)." % (self.name, self.mod_name)
            return False

        return True

    def uninstall(self, parent=None):
        '''
        Remove a plugin

        Removes the complete directory tree in case of a package.
        '''
        from .legacysupport import tkMessageBox

        if parent is None:
            parent = get_tk_focused()

        ok = tkMessageBox.askyesno('Confirm',
                'Do you really want to uninstall plugin "%s"' % (self.name), parent=parent)
        if not ok:
            return False

        showinfo = tkMessageBox.showinfo
        dirname, basename = os.path.split(self.filename)

        try:
            if basename == '__init__.py':
                import shutil
                shutil.rmtree(dirname)
            else:
                for suffix in ['', 'o', 'c']:
                    filename = self.filename + suffix
                    if os.path.exists(filename):
                        os.remove(filename)
        except OSError:
            showinfo('Error', 'Could not delete files for plugin "%s".' % (self.name), parent=parent)
            return False

        plugins.pop(self.name, None)
        autoload.pop(self.name, None)
        set_pref_changed()

        showinfo('Info', 'Plugin "%s" successfully removed. Please restart PyMOL.' % (self.name), parent=parent)
        return True

def findPlugins(paths):
    '''
    Find all python modules (extension .py and directories with __init__.py)
    inside a list of directories.

    Returns a dictionary with names to filenames mapping.
    '''
    import time
    start = time.time()

    verbose = pref_get('verbose', False)

    modules = dict()

    for path in paths:
        if not os.path.isdir(path):
            continue

        for filename in os.listdir(path):
            # ignore names that start with dot or underscore
            if filename[0] in ['.', '_']:
                continue

            if '.' in filename:
                name, _, ext = filename.partition('.')
                if ext == 'py':
                    if name not in modules:
                        modules[name] = os.path.join(path, filename)
                    elif verbose:
                        print ' warning: multiple plugins named', name
            else:
                name, filename = filename, os.path.join(path, filename, '__init__.py')
                if os.path.exists(filename):
                    if name not in modules:
                        modules[name] = filename
                    elif verbose:
                        print ' warning: multiple plugins named', name

    if verbose:
        print ' Scanning for modules took %.4f seconds' % (time.time() - start)
    return modules

# pymol commands
cmd.extend('plugin_load', plugin_load)
cmd.extend('plugin_pref_save', pref_save)

# autocompletion
cmd.auto_arg[0]['plugin_load'] = [ lambda: cmd.Shortcut(plugins), 'plugin', ''  ]

# vi:expandtab:smarttab:sw=4
